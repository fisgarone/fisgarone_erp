# app/services/ml_analytics_service.py
"""
SISTEMA DE ANÁLISES E RELATÓRIOS MERCADO LIVRE
- BASEADO NO SEU ml_service.py ORIGINAL
- COMPLEMENTA mercado_livre_service.py EXISTENTE
- FOCO EM CÁLCULOS COMPLEXOS + DASHBOARDS
"""
import logging
from datetime import datetime, timedelta
from decimal import Decimal
from sqlalchemy import text, func, case, and_, or_, extract
from sqlalchemy.orm import aliased
from app.extensions import db
from app.models.ml_models import VendaML, RepasseML
import io
import csv

logger = logging.getLogger(__name__)


class MLAnalyticsService:
    def __init__(self):
        self.cache_timeout = 300

    def _convert_br_date(self, date_str):
        """Converte data BR (DD/MM/YYYY) para objeto date - DO SEU CÓDIGO"""
        if not date_str:
            return None
        try:
            return datetime.strptime(date_str, '%d/%m/%Y').date()
        except:
            try:
                # Tenta formato ISO como fallback
                return datetime.fromisoformat(date_str).date()
            except:
                return None

    def _get_default_period(self, start, end):
        """Define período padrão - DO SEU CÓDIGO"""
        if start and end:
            return start, end
        today = datetime.now().date()
        start_date = today.replace(day=1)  # Primeiro dia do mês
        end_date = today
        return start_date, end_date

    def _build_base_query(self, company_id=None, start=None, end=None,
                          conta=None, status=None, query=None):
        """Constrói query base com filtros - DO SEU CÓDIGO ADAPTADO"""
        base_query = db.session.query(VendaML)

        # Filtro por empresa (se company_id for fornecido)
        if company_id:
            # Aqui você pode adicionar lógica para filtrar por company_id
            # baseado na relação entre Company e VendaML
            pass

        # Filtro por data
        if start and end:
            start_date = self._convert_br_date(start) if isinstance(start, str) and '/' in start else start
            end_date = self._convert_br_date(end) if isinstance(end, str) and '/' in end else end

            if isinstance(start_date, datetime):
                start_date = start_date.date()
            if isinstance(end_date, datetime):
                end_date = end_date.date()

            base_query = base_query.filter(
                and_(
                    VendaML.data_venda >= start_date.strftime('%d/%m/%Y'),
                    VendaML.data_venda <= end_date.strftime('%d/%m/%Y')
                )
            )

        # Filtros adicionais - DO SEU CÓDIGO
        if conta:
            base_query = base_query.filter(VendaML.conta == conta)
        if status:
            base_query = base_query.filter(VendaML.situacao == status)
        if query:
            base_query = base_query.filter(
                or_(
                    VendaML.id_pedido.ilike(f"%{query}%"),
                    VendaML.sku.ilike(f"%{query}%"),
                    VendaML.mlb.ilike(f"%{query}%"),
                    VendaML.titulo.ilike(f"%{query}%")
                )
            )

        return base_query

    async def health_check(self, company_id=None):
        """Verificação de saúde do sistema - BASEADO NO SEU health()"""
        try:
            count = db.session.query(VendaML).count()

            return {
                "status": "healthy" if count > 0 else "no_data",
                "vendas_count": count,
                "empresa_id": company_id,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Erro no health check: {e}")
            return {"status": "error", "error": str(e)}

    async def get_available_filters(self, company_id=None):
        """Filtros dinâmicos - BASEADO NO SEU get_filters()"""
        try:
            # Contas disponíveis
            contas = db.session.query(VendaML.conta).filter(
                VendaML.conta.isnot(None),
                VendaML.conta != ""
            ).distinct().all()

            # Status disponíveis
            status = db.session.query(VendaML.situacao).filter(
                VendaML.situacao.isnot(None),
                VendaML.situacao != ""
            ).distinct().all()

            return {
                "contas": [c[0] for c in contas if c[0]],
                "status": [s[0] for s in status if s[0]],
                "modes": ["lucro", "faturamento", "unidades", "margem"],
                "empresa_id": company_id
            }
        except Exception as e:
            logger.error(f"Erro ao buscar filtros: {e}")
            return {"contas": [], "status": [], "modes": [], "error": str(e)}

    async def get_dashboard_overview(self, company_id=None, start=None, end=None,
                                     conta=None, status=None, query=None):
        """
        KPIs PRINCIPAIS - BASEADO NO SEU get_overview()
        Cálculos complexos: pedidos, bruto, taxas, lucro_real, divergências
        """
        try:
            start_date, end_date = self._get_default_period(start, end)

            base_query = self._build_base_query(
                company_id=company_id,
                start=start_date.strftime('%d/%m/%Y'),
                end=end_date.strftime('%d/%m/%Y'),
                conta=conta,
                status=status,
                query=query
            )

            # CÁLCULOS PRINCIPAIS - DO SEU CÓDIGO
            result = base_query.with_entities(
                func.count(VendaML.id_pedido).label('pedidos'),
                func.sum(VendaML.preco_unitario * VendaML.quantidade).label('bruto'),
                func.sum(VendaML.comissoes + VendaML.taxa_fixa_ml).label('taxa_total'),
                func.sum(VendaML.frete_seller).label('frete_net'),
                func.sum(VendaML.lucro_real).label('lucro_real')
            ).first()

            bruto = float(result.bruto or 0)
            lucro_real = float(result.lucro_real or 0)
            pedidos = int(result.pedidos or 0)
            taxa_total = float(result.taxa_total or 0)
            frete_net = float(result.frete_net or 0)

            # Cálculo de margem - DO SEU CÓDIGO
            lucro_percent_medio = (lucro_real / bruto * 100) if bruto > 0 else 0

            # Repasses - DO SEU CÓDIGO (adaptado)
            repasse_real = db.session.query(func.sum(RepasseML.valor_repasse)).filter(
                RepasseML.id_pedido.in_(
                    base_query.with_entities(VendaML.id_pedido).subquery()
                )
            ).scalar() or 0

            # Divergências - DO SEU CÓDIGO
            divergencias = base_query.filter(
                or_(
                    VendaML.lucro_real < 0,
                    VendaML.preco_custo_ml == 0,
                    VendaML.frete_seller < 0
                )
            ).count()

            return {
                "pedidos": pedidos,
                "bruto": round(bruto, 2),
                "taxa_total": round(taxa_total, 2),
                "frete_net": round(frete_net, 2),
                "lucro_real": round(lucro_real, 2),
                "lucro_percent_medio": round(lucro_percent_medio, 2),
                "repasse_real": round(float(repasse_real), 2),
                "divergencias": divergencias,
                "periodo": {
                    "start": start_date.strftime('%Y-%m-%d'),
                    "end": end_date.strftime('%Y-%m-%d')
                }
            }

        except Exception as e:
            logger.error(f"Erro no dashboard overview: {e}")
            return {"error": str(e)}

    async def get_sales_trends(self, company_id=None, start=None, end=None,
                               conta=None, status=None, query=None):
        """
        TENDÊNCIAS DIÁRIAS - BASEADO NO SEU get_trends()
        Gráfico temporal com bruto, repasse, lucro por dia
        """
        try:
            start_date, end_date = self._get_default_period(start, end)

            base_query = self._build_base_query(
                company_id=company_id,
                start=start_date.strftime('%d/%m/%Y'),
                end=end_date.strftime('%d/%m/%Y'),
                conta=conta,
                status=status,
                query=query
            )

            # Agrupar por dia - DO SEU CÓDIGO
            trends_data = base_query.with_entities(
                VendaML.data_venda,
                func.sum(VendaML.preco_unitario * VendaML.quantidade).label('bruto'),
                func.sum(VendaML.lucro_real).label('lucro')
            ).group_by(VendaML.data_venda).order_by(VendaML.data_venda).all()

            # Processar repasses por dia - DO SEU CÓDIGO
            repasses_data = db.session.query(
                RepasseML.data_repasse,
                func.sum(RepasseML.valor_repasse).label('repasse')
            ).filter(
                RepasseML.id_pedido.in_(
                    base_query.with_entities(VendaML.id_pedido).subquery()
                ),
                RepasseML.data_repasse.isnot(None)
            ).group_by(RepasseML.data_repasse).all()

            # Formatando resposta - DO SEU CÓDIGO
            trends_map = {}
            for trend in trends_data:
                dia = trend.data_venda
                trends_map[dia] = {
                    "dia": dia,
                    "bruto": float(trend.bruto or 0),
                    "lucro": float(trend.lucro or 0),
                    "repasse": 0
                }

            # Adicionar repasses
            for repasse in repasses_data:
                dia = repasse.data_repasse
                if dia in trends_map:
                    trends_map[dia]["repasse"] = float(repasse.repasse or 0)

            # Ordenar por data
            sorted_trends = sorted(trends_map.values(), key=lambda x: x['dia'])

            return sorted_trends

        except Exception as e:
            logger.error(f"Erro nas trends: {e}")
            return {"error": str(e)}

    async def get_daily_metrics(self, company_id=None, start=None, end=None,
                                conta=None, status=None, query=None):
        """
        MÉTRICAS DIÁRIAS - BASEADO NO SEU get_daily()
        Cards diários com bruto e unidades
        """
        try:
            start_date, end_date = self._get_default_period(start, end)

            base_query = self._build_base_query(
                company_id=company_id,
                start=start_date.strftime('%d/%m/%Y'),
                end=end_date.strftime('%d/%m/%Y'),
                conta=conta,
                status=status,
                query=query
            )

            daily_data = base_query.with_entities(
                VendaML.data_venda,
                func.sum(VendaML.preco_unitario * VendaML.quantidade).label('bruto'),
                func.sum(VendaML.quantidade).label('unidades')
            ).group_by(VendaML.data_venda).all()

            daily_map = {row.data_venda: (float(row.bruto or 0), int(row.unidades or 0))
                         for row in daily_data}

            today = datetime.now().date()
            results = []

            # Gerar todos os dias do período
            current_date = start_date
            while current_date <= end_date:
                date_str = current_date.strftime('%d/%m/%Y')
                bruto, unidades = daily_map.get(date_str, (0.0, 0))

                results.append({
                    "dia": date_str,
                    "bruto": bruto,
                    "unidades": unidades,
                    "today": (current_date == today),
                    "future": (current_date > today),
                })

                current_date += timedelta(days=1)

            return results

        except Exception as e:
            logger.error(f"Erro nas métricas diárias: {e}")
            return {"error": str(e)}

    async def calculate_abc_curve(self, company_id=None, mode="lucro", start=None,
                                  end=None, conta=None, query=None):
        """
        CURVA ABC - BASEADO NO SEU get_abc()
        Cálculos complexos de acumulação e classificação A/B/C
        """
        try:
            start_date, end_date = self._get_default_period(start, end)

            base_query = self._build_base_query(
                company_id=company_id,
                start=start_date.strftime('%d/%m/%Y'),
                end=end_date.strftime('%d/%m/%Y'),
                conta=conta,
                query=query
            )

            # Agrupar por SKU/MLB - DO SEU CÓDIGO
            abc_data = base_query.with_entities(
                VendaML.conta,
                VendaML.sku,
                VendaML.mlb,
                VendaML.titulo,
                func.sum(VendaML.quantidade).label('unidades'),
                func.sum(VendaML.preco_unitario * VendaML.quantidade).label('faturamento'),
                func.sum(VendaML.lucro_real).label('lucro'),
                func.sum(VendaML.frete_seller).label('frete_seller')
            ).group_by(
                VendaML.conta, VendaML.sku, VendaML.mlb, VendaML.titulo
            ).all()

            # Calcular margem para cada item
            abc_calculated = []
            for item in abc_data:
                faturamento = float(item.faturamento or 0)
                lucro = float(item.lucro or 0)
                margem = (lucro / faturamento) if faturamento > 0 else 0
                frete_pct = (float(item.frete_seller or 0) / faturamento) if faturamento > 0 else 0

                abc_calculated.append({
                    "conta": item.conta,
                    "sku": item.sku,
                    "mlb": item.mlb,
                    "titulo": item.titulo,
                    "unidades": int(item.unidades or 0),
                    "faturamento_rs": faturamento,
                    "lucro_rs": lucro,
                    "margem_pct": margem,
                    "frete_seller_rs": float(item.frete_seller or 0),
                    "frete_pct": frete_pct,
                    "valor_rank": lucro if mode == "lucro" else faturamento if mode == "faturamento" else item.unidades
                })

            # Ordenar pelo critério selecionado
            abc_calculated.sort(key=lambda x: x['valor_rank'], reverse=True)

            # Calcular totais e acumulação - DO SEU CÓDIGO
            total = sum(item['valor_rank'] for item in abc_calculated)
            acumulado = 0
            results = []

            for item in abc_calculated:
                if total > 0:
                    percentual_item = (item['valor_rank'] / total) * 100
                    acumulado += percentual_item

                    # Classificar ABC - DO SEU CÓDIGO
                    if acumulado <= 80:
                        classe = "A"
                    elif acumulado <= 95:
                        classe = "B"
                    else:
                        classe = "C"
                else:
                    percentual_item = 0
                    acumulado = 0
                    classe = "C"

                results.append({
                    **item,
                    "pct_acum": round(acumulado, 2),
                    "classe": classe,
                    "valor_rank": round(item['valor_rank'], 2)
                })

            return results

        except Exception as e:
            logger.error(f"Erro na curva ABC: {e}")
            return {"error": str(e)}

    async def detect_business_anomalies(self, company_id=None, start=None, end=None,
                                        conta=None, status=None, query=None):
        """
        DETECÇÃO DE ANOMALIAS - BASEADO NO SEU get_divergences()
        Lucro negativo, custo zero, frete negativo
        """
        try:
            start_date, end_date = self._get_default_period(start, end)

            base_query = self._build_base_query(
                company_id=company_id,
                start=start_date.strftime('%d/%m/%Y'),
                end=end_date.strftime('%d/%m/%Y'),
                conta=conta,
                status=status,
                query=query
            )

            # Buscar anomalias - DO SEU CÓDIGO
            anomalies = base_query.filter(
                or_(
                    VendaML.lucro_real < 0,
                    VendaML.preco_custo_ml == 0,
                    VendaML.frete_seller < 0
                )
            ).all()

            results = []
            for anomaly in anomalies:
                issues = []
                if anomaly.lucro_real and float(anomaly.lucro_real) < 0:
                    issues.append("Lucro negativo")
                if anomaly.preco_custo_ml and float(anomaly.preco_custo_ml) == 0:
                    issues.append("Sem preço de custo")
                if anomaly.frete_seller and float(anomaly.frete_seller) < 0:
                    issues.append("Frete seller negativo")

                results.append({
                    "id_pedido_ml": anomaly.id_pedido,
                    "conta": anomaly.conta,
                    "sku": anomaly.sku,
                    "mlb": anomaly.mlb,
                    "titulo": anomaly.titulo,
                    "lucro": float(anomaly.lucro_real or 0),
                    "custo": float(anomaly.preco_custo_ml or 0),
                    "frete_seller": float(anomaly.frete_seller or 0),
                    "dia": anomaly.data_venda,
                    "issues": issues
                })

            return results

        except Exception as e:
            logger.error(f"Erro na detecção de anomalias: {e}")
            return {"error": str(e)}

    async def get_top_items(self, company_id=None, n=10, mode="lucro", start=None,
                            end=None, conta=None, query=None):
        """
        TOP ITENS - BASEADO NO SEU get_top_items()
        Ranking com comparação temporal
        """
        try:
            # Implementação similar à ABC, mas com limite e comparação
            abc_data = await self.calculate_abc_curve(
                company_id=company_id,
                mode=mode,
                start=start,
                end=end,
                conta=conta,
                query=query
            )

            return abc_data[:n]

        except Exception as e:
            logger.error(f"Erro no top items: {e}")
            return {"error": str(e)}

    async def export_analytics_data(self, company_id=None, format_type="csv",
                                    filters=None):
        """
        EXPORTAÇÃO DE DADOS - BASEADO NO SEU export_orders_csv/xlsx()
        Sistema de exportação robusto
        """
        try:
            filters = filters or {}
            data = await self.calculate_abc_curve(
                company_id=company_id,
                mode=filters.get('mode', 'lucro'),
                start=filters.get('start'),
                end=filters.get('end'),
                conta=filters.get('conta'),
                query=filters.get('query')
            )

            if format_type.lower() == "csv":
                return self._export_abc_to_csv(data)
            else:
                return self._export_abc_to_xlsx(data)

        except Exception as e:
            logger.error(f"Erro na exportação: {e}")
            return {"error": str(e)}

    def _export_abc_to_csv(self, data):
        """Exporta curva ABC para CSV - DO SEU CÓDIGO"""
        output = io.StringIO()
        writer = csv.writer(output, delimiter=';')

        writer.writerow([
            "Conta", "SKU", "MLB", "Título", "Unidades", "Faturamento (R$)",
            "Lucro (R$)", "Margem (%)", "Frete Seller (R$)", "Frete/Bruto (%)",
            "Acumulado (%)", "Classe"
        ])

        for item in data:
            writer.writerow([
                item.get("conta") or "",
                item.get("sku") or "",
                item.get("mlb") or "",
                item.get("titulo") or "",
                item.get("unidades") or 0,
                f"{item.get('faturamento_rs') or 0:.2f}".replace(".", ","),
                f"{item.get('lucro_rs') or 0:.2f}".replace(".", ","),
                f"{(item.get('margem_pct') or 0) * 100:.2f}".replace(".", ","),
                f"{item.get('frete_seller_rs') or 0:.2f}".replace(".", ","),
                f"{(item.get('frete_pct') or 0) * 100:.2f}".replace(".", ","),
                f"{item.get('pct_acum') or 0:.2f}".replace(".", ","),
                item.get("classe") or ""
            ])

        return output.getvalue()

    def _export_abc_to_xlsx(self, data):
        """Exporta curva ABC para XLSX - DO SEU CÓDIGO (simplificado)"""
        # Implementação com openpyxl ou xlsxwriter
        # Por enquanto retornamos CSV como fallback
        return self._export_abc_to_csv(data)


# Instância global do serviço
ml_analytics = MLAnalyticsService()